## 1. 单模式串匹配概述

> **单模式串匹配**：是指在文本串 $T$ 中查找一个模式串 $p$ 的所有出现位置的问题。这是字符串匹配中最基础、最经典的问题。
>
> - **问题定义**：给定一个长度为 $n$ 的文本串 $T$ 和一个长度为 $m$ 的模式串 $p$，找出模式串 $p$ 在文本串 $T$ 中所有出现的位置。

### 1.1 问题描述

单模式串匹配问题是字符串匹配的基础问题，其形式化定义如下：

- **输入**：文本串 $T = T[0...n-1]$，模式串 $p = p[0...m-1]$
- **输出**：所有满足 $T[i...i+m-1] = p[0...m-1]$ 的位置 $i$
- **目标**：高效地找到所有匹配位置

### 1.2 应用场景

单模式串匹配在计算机科学和实际应用中有广泛的应用：

- **文本编辑器**：查找和替换功能
- **生物信息学**：DNA序列匹配
- **网络安全**：入侵检测系统中的模式识别
- **数据挖掘**：文本挖掘和信息检索
- **编译原理**：词法分析中的关键字识别

## 2. 单模式串匹配算法分类

根据算法的核心思想和复杂度，单模式串匹配算法可以分为以下几类：

### 2.1 朴素算法

**Brute Force 算法（暴力匹配算法）**
- **时间复杂度**：$O(n \times m)$
- **空间复杂度**：$O(1)$
- **特点**：简单直观，但效率较低
- **适用场景**：模式串较短或对性能要求不高的场景

### 2.2 基于哈希的算法

**Rabin Karp 算法**
- **时间复杂度**：平均 $O(n + m)$，最坏 $O(n \times m)$
- **空间复杂度**：$O(1)$
- **特点**：使用滚动哈希，平均性能较好
- **适用场景**：需要处理多个模式串或对哈希冲突不敏感的场景

### 2.3 基于有限状态机的算法

**KMP 算法（Knuth-Morris-Pratt 算法）**
- **时间复杂度**：$O(n + m)$
- **空间复杂度**：$O(m)$
- **特点**：利用失配信息避免重复比较
- **适用场景**：对性能要求较高的场景

### 2.4 基于启发式规则的算法

**Boyer Moore 算法**
- **时间复杂度**：平均 $O(n/m)$，最坏 $O(n \times m)$
- **空间复杂度**：$O(k)$（$k$ 为字符集大小）
- **特点**：从右到左比较，跳跃能力强
- **适用场景**：模式串较长，字符集较小的场景

**Horspool 算法**
- **时间复杂度**：平均 $O(n)$，最坏 $O(n \times m)$
- **空间复杂度**：$O(k)$
- **特点**：BM算法的简化版本，实现简单
- **适用场景**：需要简单实现的场景

**Sunday 算法**
- **时间复杂度**：平均 $O(n)$，最坏 $O(n \times m)$
- **空间复杂度**：$O(k)$
- **特点**：从左到右比较，跳跃能力强
- **适用场景**：需要从左到右匹配的场景

## 3. 算法复杂度对比

| 算法 | 预处理时间 | 匹配时间 | 空间复杂度 | 特点 |
|------|------------|----------|------------|------|
| Brute Force | $O(1)$ | $O(n \times m)$ | $O(1)$ | 简单直观 |
| Rabin Karp | $O(m)$ | 平均 $O(n)$，最坏 $O(n \times m)$ | $O(1)$ | 滚动哈希 |
| KMP | $O(m)$ | $O(n)$ | $O(m)$ | 失配信息 |
| Boyer Moore | $O(m + k)$ | 平均 $O(n/m)$，最坏 $O(n \times m)$ | $O(k)$ | 启发式跳跃 |
| Horspool | $O(m + k)$ | 平均 $O(n)$，最坏 $O(n \times m)$ | $O(k)$ | BM简化版 |
| Sunday | $O(m + k)$ | 平均 $O(n)$，最坏 $O(n \times m)$ | $O(k)$ | 从左到右 |

## 4. 算法选择策略

### 4.1 根据应用场景选择

- **简单应用**：选择 Brute Force 算法，代码简单，易于理解和维护
- **一般应用**：选择 KMP 算法，性能稳定，实现相对简单
- **高性能应用**：选择 Boyer Moore 算法，平均性能最优
- **多模式串应用**：选择 Rabin Karp 算法，易于扩展到多模式串

### 4.2 根据数据特征选择

- **模式串较短（$m < 10$）**：Brute Force 算法足够
- **模式串较长（$m > 50$）**：Boyer Moore 算法优势明显
- **字符集较小**：Boyer Moore、Horspool、Sunday 算法效果好
- **字符集较大**：KMP 算法更稳定

### 4.3 根据实现复杂度选择

- **快速原型**：Brute Force 或 Horspool 算法
- **生产环境**：KMP 或 Boyer Moore 算法
- **教学演示**：Brute Force 或 KMP 算法

## 5. 实际应用中的考虑

### 5.1 内存使用

- **嵌入式系统**：选择空间复杂度低的算法
- **大规模文本处理**：考虑算法的缓存友好性

### 5.2 预处理开销

- **一次性匹配**：预处理开销相对不重要
- **多次匹配**：预处理开销分摊后影响较小

### 5.3 字符集特性

- **ASCII 字符**：所有算法都适用
- **Unicode 字符**：需要考虑字符编码问题
- **二进制数据**：需要特殊处理

## 6. 总结

单模式串匹配是字符串算法的基础问题，不同的算法各有优缺点：

- **Brute Force**：最简单，适合学习和简单应用
- **Rabin Karp**：适合多模式串和哈希应用
- **KMP**：理论最优，实际应用广泛
- **Boyer Moore**：平均性能最优，适合长模式串
- **Horspool/Sunday**：BM的简化版本，实现简单

## 练习题目

- [单模式串匹配题目列表](https://github.com/ITCharge/AlgoNote/tree/main/docs/00_preface/00_06_categories_list.md#%E5%8D%95%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%A2%98%E7%9B%AE)

## 参考资料

- 【书籍】算法导论 - Thomas H. Cormen 等著
- 【书籍】柔性字符串匹配 - 中科院计算所网络信息安全研究组 译
- 【文章】[字符串匹配基础（上）- 数据结构与算法之美 - 极客时间](https://time.geekbang.org/column/article/71187)
- 【文章】[字符串匹配算法总结 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)
